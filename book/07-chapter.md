## Фабрики для DTO

Я расскажу о двух возможных способах создания DTO, а также объясню, какой из них мне больше нравится.

### Первый способ: использование выделенной фабрики

Это наиболее правильный подход: использование отдельной фабрики.

```php
class CustomerDataFactory
{
    public function fromRequest(CustomerRequest $request): CustomerData {
        return new CustomerData([
            'name' => $request->get('name'),
            'email' => $request->get('email'),
            'birth_date' => Carbon::make($request->get('birth_date')),
        ]);
    }
}
```

Использование отдельной фабрики помогает сохранить чистоту кода во всем проекте. Я бы сказал, что логичнее всего такую
фабрику размещать в **слое приложения**, так как она должна знать о специфике запросов и других типов пользовательского
ввода.

### Второй способ: упрощённый подход

Несмотря на правильность первого способа, обратили ли вы внимание, что в прошлом примере я использовал сокращённый
метод? Именно так, он находится прямо в самом классе DTO:

```php
CustomerData::fromRequest().
```

**В чём проблема с этим подходом?**

Во-первых, он добавляет логику, специфичную для приложения, в доменный слой. Это означает, что класс DTO, находящийся в
доменном слое, теперь вынужден знать о классе `CustomerRequest`, который относится к слою приложения.

Это нарушает принцип разделения ответственности, поскольку доменный слой, в идеале, не должен зависеть от структуры или
логики, относящихся к слою приложения.

```php
use Spatie\DataTransferObject\DataTransferObject;

class CustomerData extends DataTransferObject
{
    public static function fromRequest(CustomerRequest $request): self {
        return new self([
            'name' => $request->get('name'),
            'email' => $request->get('email'),
            'birth_date' => Carbon::make($request->get('birth_date')),
        ]);
    }
}
```

Очевидно, что смешивание кода, специфичного для приложения, с доменным слоем — не лучшая идея. Однако именно этот подход
является моим предпочтением.

Есть две причины для этого:

1. **DTO как точка входа данных в систему**  
   Мы уже определили, что DTO являются точкой входа данных в кодовую базу. Как только мы начинаем работать с данными из
   внешних источников, их нужно преобразовать в DTO. Такое преобразование нужно выполнять где-то, так почему бы не
   делать это в рамках самого класса, к которому это относится?

2. **Ограничение языка PHP**  
   Вторая, и более значимая причина — одно из ограничений PHP: он не поддерживает *именованные параметры* (по крайней
   мере, пока). Из-за этого более практично и логично выполнять преобразование данных прямо в методе класса DTO.

Смотрите, вы не хотите, чтобы ваши DTO содержали конструктор с отдельным параметром для каждого свойства: такой подход
не масштабируется и становится очень запутанным, особенно при работе с nullable- или свойствами с значениями по
умолчанию. Именно поэтому я предпочитаю подход передачи массива в DTO, который затем сам себя строит на основе данных из
этого массива. Кстати, для этой цели мы используем наш пакет **spatie/data-transfer-object**.

Поскольку именованные параметры не поддерживаются, статический анализ также невозможен. Это означает, что вы не знаете
точно, какие данные необходимы при создании DTO. Я предпочитаю держать это "неведение" внутри самого класса DTO, чтобы
он мог использоваться извне без дополнительных размышлений.

Если бы PHP поддерживал что-то вроде именованных параметров (а это станет возможным в PHP 8), я бы сказал, что
использование паттерна "фабрика" — это лучший подход:

```php
public function fromRequest(CustomerRequest $request): CustomerData {
    return new CustomerData(
        name: $request->get('name'),
        email: $request->get('email'),
        birth_date: Carbon::make(
            $request->get('birth_date')
        ),
    );
}
```

До тех пор, пока PHP не будет поддерживать это, я бы выбрал прагматичное решение, а не теоретически правильное. Однако
выбор остаётся за вами — смело выбирайте то, что лучше подходит вашей команде.
