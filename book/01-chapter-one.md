## Laravel, ориентированный на домен

> Люди мыслят категориями, и наш код должен это отражать.

Прежде всего: я не сам придумал термин «домен» — я позаимствовал его из популярной парадигмы программирования DDD,
или «Domain-Driven Design» (доменно-ориентированное проектирование). Это довольно обобщённый термин. Согласно
Оксфордскому словарю, «домен» можно описать как «определённую сферу деятельности или знаний».

Хотя моё использование слова «домен» не будет полностью совпадать с его значением в сообществе DDD, между этими
понятиями есть несколько схожих черт. Если вы знакомы с DDD, то обнаружите эти сходства на протяжении всей
книги. Я постарался максимально подробно указать на общие моменты, а также различия, там, где это было уместно.

Итак, домены. Вы также могли бы назвать их «группами», «модулями» или, как иногда говорят, «сервисами». Какое бы
название вам ни нравилось больше, домены описывают набор бизнес-задач, которые вы стремитесь решить.

Подождите... Я только что использовал первый «корпоративный» термин в этой книге: «бизнес-задача». Читая дальше, вы
заметите, что я старался избегать теоретических, управленческих и бизнес-ориентированных вещей. Я сам разработчик и
предпочитаю оставаться в рамках практики. Поэтому можно использовать более простое название — «проект».

Приведем пример: приложение для управления бронированием отелей. Оно должно обрабатывать работу с клиентами,
бронированиями, счетами, инвентаризацией отелей и так далее.

Современные фреймворки для веб-разработки предлагают взять одну группу связанных понятий и разделить их по разным частям
вашего кода: контроллеры к контроллерам, модели к моделям и так далее. Вы понимаете, о чем речь.

Давайте остановимся и подумаем об этом на минуту.

Клиент когда-нибудь говорил вам: «поработайте над контроллерами» или «сосредоточьтесь на директории моделей»? Нет, они
просят вас работать над функциями выставления счетов, управления клиентами или бронирования.

Эти группы и есть то, что я называю доменами. Они стремятся объединить в вашем проекте концепции, которые логически
связаны друг с другом. Хотя на первый взгляд это может показаться тривиальным, на самом деле всё намного сложнее, чем вы
думаете. Именно поэтому часть этой книги будет сосредоточена на наборе правил и практик, чтобы ваш код оставался
аккуратно организованным.

Очевидно, что я не могу дать вам математическую формулу, так как почти всё зависит от конкретного проекта, над которым
вы работаете. Так что не воспринимайте эту книгу как фиксированный набор правил. Скорее, думайте о ней как о коллекции
идей, которые вы можете использовать и развивать на своё усмотрение.

Это возможность для обучения, а не готовое решение, которое можно применить ко всему, что встречается на вашем пути.

## Домены и приложения

Если мы объединяем идеи в группы, естественно, возникает вопрос: как далеко мы можем зайти? Вы могли бы, например,
объединить всё, что связано с работой со счетами:

- модели,
- контроллеры,
- ресурсы,
- правила валидации,
- задания (jobs),
  и многое другое.

Однако такой подход приводит к проблеме в классических HTTP-приложениях: зачастую не существует однозначного
соответствия между контроллерами и моделями. Конечно, в REST API и большинстве классических CRUD-контроллеров может быть
строгая связь один к одному. К сожалению, из правил всегда есть исключения, и именно они создают нам сложности.

---

#### Пример:

Счета (Invoices) **не работают изолированно**:

- для счёта нужен клиент, чтобы отправить его,
- требуются бронирования, чтобы указать, по какому заказу выставлен счёт,
- и это только часть взаимосвязей.

---

Вот почему мы должны чётко различать:

- **Домен** — это бизнес-логика, которая отвечает за правила и операции.
- **Приложение** — это код, который использует домен, интегрирует его с фреймворком, обеспечивают инфраструктуру,
  которая позволяет конечным пользователям получить доступ к функциональности домена и взаимодействовать с ней удобным
  образом.

Мы посвятим отдельную главу этому различию, чтобы подробно его разобрать.  
Но уже сейчас важно понимать:  **доменный код и код приложения — это два разных слоя**.

## Домены на практике

Как всё, что описано выше, выглядит на практике?

Доменный код обычно состоит из различных классов:

- моделей,
- построителей запросов (query builders),
- доменных событий,
- правил валидации
  и других компонентов. Мы подробно рассмотрим каждый из этих элементов.

**Слой приложения** будет представлять одно или несколько приложений. Каждое приложение можно рассматривать как
отдельное приложение, которое имеет право использовать весь доменный код. Как правило, приложения не взаимодействуют
друг с другом, по крайней мере, напрямую.

**Пример:**
Это может быть стандартная HTTP-панель администратора, а другое — REST API. Мне также нравится рассматривать консоль,
Artisan в Laravel, как отдельное приложение.

Пример структуры папок доменно-ориентированного проекта:

```
src/Domain/Invoices/
├── Actions
├── QueryBuilders
├── Collections
├── DataTransferObjects
├── Events
├── Exceptions
├── Listeners
├── Models
├── Rules
└── States

src/Domain/Customers/
// …
```

А вот как может выглядеть слой приложения:

```
HTTP-приложение для административной панели:
src/App/Admin/
├── Controllers
├── Middlewares
├── Requests
├── Resources
└── ViewModels

The REST API application:
src/App/Api/
├── Controllers
├── Middlewares
├── Requests
└── Resources

The console application:
src/App/Console/
└── Commands
```

Вы, возможно, заметили, что этот пример не следует стандартам Laravel, где корневым пространством имен является `\App`.
Поскольку приложения — это **лишь часть проекта**, и их может быть несколько, использование `\App` в качестве корня для
всех компонентов не имеет смысла.

Если вы предпочитаете придерживаться стандартной структуры Laravel, вы можете так сделать. Помните, эта книга **не
навязывает строгие правила**, а учит вас определённому подходу. Вы вольны выбирать те паттерны и решения, которые лучше
всего подходят для ваших задач.

Если вы всё же хотите разделить корневые пространства имён, вы можете сделать это, внеся небольшое изменение в
`composer.json`:

```json
{
  // …

  "autoload": {
    "psr-4": {
      "App\\": "src/App/",
      "Domain\\": "src/Domain/",
      "Support\\": "src/Support/"
    }
  }
}
```

Обратите внимание, что здесь также есть пространство имён `Support`. Вы можете думать о нем как о "свалке" для всех
мелких вспомогательных функций, которые не подходят никуда больше. Вы увидите практическое использование пространства
имён `Support` в последующих главах.

К сожалению, вам нужно сделать ещё один шаг, чтобы Laravel полностью поддерживал ваши нестандартные пространства имён.  
По умолчанию Laravel ищет код из пространства имён `App\` внутри папки `app/`, и эта настройка является жёстко заданной
в классе `\Illuminate\Foundation\Application`.

К счастью, мы можем легко создать свою собственную версию, следующим образом:

```php
namespace App;

class Application extends \Illuminate\Foundation\Application
{
    protected $namespace = 'App\\';
}
```

И переопределить это в `bootstrap/app.php`, следующим образом:

```php
use App\Application;

$app = new Application(
    $_ENV['APP_BASE_PATH'] ?? dirname(__DIR__)
))->useAppPath('src/App');
```

Опять же, вы не обязаны делать это, если хотите придерживаться стандартной структуры Laravel.

Независимо от выбранной структуры папок, **очень важно начать мыслить группами, объединёнными бизнес-концепцией**, а не
группами кода, имеющими схожие технические свойства.

Внутри каждой группы — то есть домена — есть место для организации кода любым способом, который имеет смысл именно для
этой группы. Первая часть этой книги сосредоточится на том, как можно структурировать домены изнутри и какие паттерны можно
использовать для того, чтобы ваш код оставался поддерживаемым по мере роста проекта. После этого мы рассмотрим слой приложения: как домен может быть подключён к нему, и как мы можем улучшить стандартные
концепции Laravel, используя, например, view-модели.

Нам предстоит охватить много тем, так что давайте начнём!
