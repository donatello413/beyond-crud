## Домены на практике

Как всё, что описано выше, выглядит на практике?

Доменный код обычно состоит из различных классов:

- моделей,
- построителей запросов (query builders),
- доменных событий,
- правил валидации
  и других компонентов. Мы подробно рассмотрим каждый из этих элементов.

**Слой приложения** будет представлять одно или несколько приложений. Каждое приложение можно рассматривать как
отдельное приложение, которое имеет право использовать весь доменный код. Как правило, приложения не взаимодействуют
друг с другом, по крайней мере, напрямую.

**Пример:**
Это может быть стандартная HTTP-панель администратора, а другое — REST API. Мне также нравится рассматривать консоль,
Artisan в Laravel, как отдельное приложение.

Пример структуры папок доменно-ориентированного проекта:

```
src/Domain/Invoices/
├── Actions
├── QueryBuilders
├── Collections
├── DataTransferObjects
├── Events
├── Exceptions
├── Listeners
├── Models
├── Rules
└── States

src/Domain/Customers/
// …
```

А вот как может выглядеть слой приложения:

```
HTTP-приложение для административной панели:
src/App/Admin/
├── Controllers
├── Middlewares
├── Requests
├── Resources
└── ViewModels

The REST API application:
src/App/Api/
├── Controllers
├── Middlewares
├── Requests
└── Resources

The console application:
src/App/Console/
└── Commands
```

Вы, возможно, заметили, что этот пример не следует стандартам Laravel, где корневым пространством имен является `\App`.
Поскольку приложения — это **лишь часть проекта**, и их может быть несколько, использование `\App` в качестве корня для
всех компонентов не имеет смысла.

Если вы предпочитаете придерживаться стандартной структуры Laravel, вы можете так сделать. Помните, эта книга **не
навязывает строгие правила**, а учит вас определённому подходу. Вы вольны выбирать те паттерны и решения, которые лучше
всего подходят для ваших задач.

Если вы всё же хотите разделить корневые пространства имён, вы можете сделать это, внеся небольшое изменение в
`composer.json`:

```json
{
  // …

  "autoload": {
    "psr-4": {
      "App\\": "src/App/",
      "Domain\\": "src/Domain/",
      "Support\\": "src/Support/"
    }
  }
}
```

Обратите внимание, что здесь также есть пространство имён `Support`. Вы можете думать о нем как о "свалке" для всех
мелких вспомогательных функций, которые не подходят никуда больше. Вы увидите практическое использование пространства
имён `Support` в последующих главах.

К сожалению, вам нужно сделать ещё один шаг, чтобы Laravel полностью поддерживал ваши нестандартные пространства имён.  
По умолчанию Laravel ищет код из пространства имён `App\` внутри папки `app/`, и эта настройка является жёстко заданной
в классе `\Illuminate\Foundation\Application`.

К счастью, мы можем легко создать свою собственную версию, следующим образом:

```php
namespace App;

class Application extends \Illuminate\Foundation\Application
{
    protected $namespace = 'App\\';
}
```

И переопределить это в `bootstrap/app.php`, следующим образом:

```php
use App\Application;

$app = new Application(
    $_ENV['APP_BASE_PATH'] ?? dirname(__DIR__)
))->useAppPath('src/App');
```

Опять же, вы не обязаны делать это, если хотите придерживаться стандартной структуры Laravel.

Независимо от выбранной структуры папок, **очень важно начать мыслить группами, объединёнными бизнес-концепцией**, а не
группами кода, имеющими схожие технические свойства.

Внутри каждой группы — то есть домена — есть место для организации кода любым способом, который имеет смысл именно для
этой группы. Первая часть этой книги сосредоточится на том, как можно структурировать домены изнутри и какие паттерны можно
использовать для того, чтобы ваш код оставался поддерживаемым по мере роста проекта. После этого мы рассмотрим слой приложения: как домен может быть подключён к нему, и как мы можем улучшить стандартные
концепции Laravel, используя, например, view-модели.

Нам предстоит охватить много тем, так что давайте начнём!
