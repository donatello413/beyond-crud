## Структурирование неструктурированных данных

Приходилось ли вам когда-нибудь работать с «массивом чего-то», который на самом деле был больше, чем просто список?
Использовали ли вы ключи массива в качестве полей? И ощущали ли вы трудности из-за того, что точно не знали, что
содержится в этом массиве? А как насчёт того, что вы не были уверены, соответствует ли содержащиеся в массиве данные
вашим ожиданиям или какие поля в нём вообще доступны?

Давайте визуализируем, о чём идёт речь: например, работа с запросами в Laravel. Подумайте о таком примере, как базовая
CRUD-операция для обновления существующего клиента.

```php
function store(CustomerRequest $request, Customer $customer)
{
    $validated = $request->validated();
    $customer->name = $validated['name'];
    $customer->email = $validated['email'];
}
```

Вы, возможно, уже видите проблему: мы не знаем точно, какие данные доступны в массиве `$validated`. Хотя массивы в PHP —
это универсальная и мощная структура данных, как только они используются для представления чего-то большего, чем «список
вещей», существуют более подходящие способы решения вашей задачи.

Прежде чем рассмотреть решения, вот что можно было бы сделать в подобной ситуации:

- Прочитать исходный код
- Изучить документацию
- Вывести содержимое `$validated` на экран
- Использовать отладчик для его изучения

А теперь представьте, что вы работаете над этим проектом в команде из нескольких разработчиков, и один из ваших коллег
написал этот код пять месяцев назад. Гарантирую, что вы точно не узнаете, с какими данными вы имеете дело, без
выполнения одного из вышеуказанных трудоёмких шагов.

Оказывается, системы, основанные на строгой типизации в сочетании со статическим анализом, могут значительно облегчить
понимание того, с чем именно мы работаем. Например, языки вроде Rust решают эту проблему элегантно:

```rust
struct CustomerData {
    name: String,
    email: String,
    birth_date: Date,
}
```

На самом деле, структура (struct) — это именно то, что нам нужно. Но, к сожалению, в PHP нет структур. У нас есть только
массивы и объекты.

Однако, объектов и классов может оказаться достаточно:

```php
class CustomerData
{
    public string $name;
    public string $email;
    public Carbon $birth_date;
}
```

Это чуть более многословно, но по сути делает то же самое. Такой простой объект можно использовать следующим образом:

```php
function store(CustomerRequest $request, Customer $customer)
{
    $validated = CustomerData::fromRequest($request);
    $customer->name = $validated->name;
    $customer->email = $validated->email;
    $customer->birth_date = $validated->birth_date;
}
```

Статический анализатор, встроенный в вашу IDE, всегда сможет подсказать, с какими данными вы работаете.

Этот подход, заключающий неструктурированные данные в типы, чтобы мы могли работать с такими данными надежным образом,
называется **“объекты передачи данных” (data transfer objects, DTOs)**. Это первый конкретный шаблон, который я
настоятельно рекомендую использовать в ваших проектах Laravel, объем которых превышает среднестатистический.

Обсуждая этот подход с коллегами, друзьями или в Laravel-сообществе, вы можете столкнуться с людьми, которые не
разделяют видения о преимуществах строгой типизации. На самом деле существует много людей, которые предпочитают
использовать динамическую/слабую сторону PHP, и, конечно, у этого подхода тоже есть свои плюсы.

Однако, по моему опыту, при работе в команде из нескольких разработчиков над проектом в течение продолжительного времени
преимущества строгой типизации перевешивают. Вы должны использовать каждую возможность, чтобы снизить когнитивную
нагрузку. Вы точно не хотите, чтобы разработчикам приходилось начинать отладку кода каждый раз, когда они хотят узнать,
что именно находится в переменной. Эта информация должна быть доступна сразу, чтобы они могли сосредоточиться на более
важных вещах: создании приложения.

Конечно, использование DTO связано с определенной ценой: не только дополнительные усилия на определение этих классов, но
и необходимость, например, сопоставления данных запроса с DTO. Тем не менее, преимущества DTO значительно перевешивают
эти затраты: время, потраченное на создание этих классов, компенсируется в долгосрочной перспективе.

Но всё же остаётся важный вопрос: **как создавать DTO из “внешних” данных?**